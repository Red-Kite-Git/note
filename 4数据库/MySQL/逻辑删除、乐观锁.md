# 逻辑删除、乐观锁

## 一、逻辑删除

|            | 逻辑删除                                                     | 物理删除                                                     |
| :--------- | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 定义       | 通过修改数据的状态标志或添加特定字段来表示数据已被删除，但数据实际仍存在于数据库中。 | 直接从数据库中永久删除数据记录，数据在存储介质上被真正移除。 |
| 数据恢复   | 相对容易，只需修改相应的状态标志或删除标记即可恢复数据。     | 通常较难恢复，除非有数据库备份或使用专门的数据恢复工具和技术。 |
| 操作性能   | 一般较快，只涉及对记录的标志位进行更新，不需要移动或删除大量数据。 | 可能较慢，尤其是在删除大量数据时，需要执行磁盘 I/O 操作来移除数据，可能会引起表的重组等操作。 |
| 事务处理   | 在事务中，逻辑删除可以很容易地回滚，只需撤销对标志位的修改。 | 物理删除在事务中回滚相对复杂，可能需要从备份中恢复数据或执行反向操作来重新插入已删除的数据。 |
| 数据完整性 | 可以通过约束条件等确保数据的完整性，因为数据本身并未真正删除，相关的外键约束等仍可正常工作。 | 如果删除不当，可能会破坏数据的完整性，例如删除了有外键关联的数据，导致引用完整性问题。 |
| 适用场景   | 适用于需要保留数据历史记录，以便进行审计、统计分析或可能需要恢复数据的场景，如电商订单的软删除，方便查询历史订单信息。 | 适用于确定不再需要的数据，如临时数据、测试数据或已过期且无保留价值的数据。 |
| 存储空间   | 不会立即释放存储空间，数据仍占据一定的磁盘空间，需要定期清理或进行数据归档。 | 会立即释放被删除数据所占用的存储空间，有助于优化数据库的存储效率。 |

▼ 物理删除示例

```mysql
DELETE FROM user WHERE id = 1;
```

▼ 逻辑删除示例

```mysql
UPDATE user SET deleted = 1 WHERE id = 1;
```



## 二、乐观锁

乐观锁假定在大多数情况下，多个事务不会同时对同一数据进行修改，所以在事务开始时不会对数据加锁。在更新数据时，会检查数据是否被其他事务修改过，若被修改过则回滚当前事务。

#### 优点

* **高并发性能**：由于无需加锁，可提高系统的并发性能。
* **减少死锁风险**：不存在锁的竞争，降低了死锁的可能性。

#### 缺点

* **冲突处理复杂**：若发生冲突，需要对事务进行回滚和重试，处理逻辑较为复杂。
* **不适用于高冲突场景**：在高冲突场景下，事务回滚和重试的次数会增多，影响系统性能。

#### 示例

假设存在一个`products`表，表中有`id`、`name`、`price`和`version`四个字段，`version`字段用于实现乐观锁。

```sql
-- 创建表
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10, 2),
    version INT DEFAULT 0
);

-- 插入数据
INSERT INTO products (id, name, price) VALUES (1, 'iPhone', 999.99);

-- 模拟两个事务同时更新数据

-- 事务 1
START TRANSACTION;
SELECT id, name, price, version FROM products WHERE id = 1;
-- 假设查询结果为 (1, 'iPhone', 999.99, 0)
UPDATE products SET price = 1099.99, version = version + 1 WHERE id = 1 AND version = 0;
-- 执行成功，version 变为 1
COMMIT;

-- 事务 2
START TRANSACTION;
SELECT id, name, price, version FROM products WHERE id = 1;
-- 假设查询结果为 (1, 'iPhone', 999.99, 0)
UPDATE products SET price = 1199.99, version = version + 1 WHERE id = 1 AND version = 0;
-- 执行失败，因为 version 已经变为 1
ROLLBACK;
```