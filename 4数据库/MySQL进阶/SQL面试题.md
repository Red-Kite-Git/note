## 一、事务的隔离级别
### 1.读未提交	(READ UNCOMMITTED)
会产生：脏读 不可重复读 幻读
一个事务在执行过程中可以看到其他事务没有提交的新插入的记录和更新的记录

### 2.读已提交	(READ COMMITTED)
会产生：不可重复读 幻读
当数据库系统使用读已提交隔离级别时，一个事务在执行过程中能看到其他事务已经提交的新增和更新的记录

### 3.可重复读	(REPEATABLE READ)
会产生：幻读 
一个事务在执行过程中不能看到其他事务已经提交的更新的记录,但 是可以看到其他事务已经提交的新增的记录。MySQL数据库的隔离级别是可重复读。（但是MySQL的可重复读不会出现幻读）

### 4.串行化	 (SERIALIZABLE)

不会产生：脏读 不可重复读 幻读
数据库系统使用串行化隔离级别时，一个事务在执行过程中完全看不到其他事务对数据库所做的更 新。当两个事务同时操作数据库中相同数据时，如果第一个事务 已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此这两个事务实际上是串行化方式运行。

## 二、不同的数据库隔离级别产生的问题
### 1.脏写
事务A去修改数据库的一个值，还未提交时，事务B去修改了事务A修改过的值，但此时事务A回滚导致事务B修改的值也没了
### 2.脏读 
事务A去查询一个数据，此时事务B修改数据还没提交， 事务B回滚后导致事务A再次查询就读不到刚才事务B修改的还未提交的数据
### 3.不可重复读 
假设缓存页里一条数据原来的值是A值，此时事务A开启之后，第 一次查询这条数据，读取到的就是A值。接着事务B更新了那行数 据的值为B值，同时事务B立马提交。然后事务A此时可是还没提 交，他在事务执行期间第二次查询数据，此时查到的是事务B修改 过的B值，因为事务B已经提交了，所以事务A可以读到最新的 值。紧接着事务C再次更新数据为C值，并且提交事务了，此时事 务A在没提交的情况下，第三次查询数据，查到的值为C值。按照程序具体的要求是允许不可重复读还是允许重复读，可能是一个问题也可能不是一个问题
### 4.幻读
幻读指的就是你一个事务用一样的SQL多次查询，结果每次查询 都会发现查到了一些之前没看到过的数据。注意，幻读特指的是 你查询到了之前查询没看到过的数据!此时就说你是幻读了。 

## 三、事务的特性 
原子性(Atomicity) 事务中的所有操作要么全部执行，要么都不执行。如果事务没有 原子性的保证，那么在发生系统 故障的情况下，数据库就有可能 处于不一致状态。 一致性(Consistency) 主要强调的是，如果在执行事务之前数据库是一致的，那么在执 行事务之后数据库也还是一致的。所谓一致性简单地说就是数据 库中数据的完整性，包括它们的正确性。 隔离性(Isolation) 即使多个事务并发（同时）执行，每个事务都感觉不到系统中有 其他的事务在执行，因而也就能保证数据库的一致性。 持久性(Durability) 事务成功执行后它对数据库的修改是永久的，即使系统出现故障 也不受影响。 

## 四、数据库设计的三大范式

第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果 数据库表中的所有字段值都是不可分解的原子值,就说明该数据库 表满足了第一范式。 第二范式在第一范式的基础之上更进一层。第二范式需要确保数 据库表中的每一列都和主键相关。就是说在一个数据库表中，一 个表中只能保存一种数据，不可以把多种数据保存在同一张数据 库表中。 第三范式需要确保数据表中的每一列数据都和主键直接相关，而 不能间接相关。 

## 五、InnoDB 引擎的数据库表

如果没有在表上创建主键,这张表上是否 有主键 如果表中没有定义主键，则InnoDB会选择第一个不包含有NULL 值的唯一索引作为主键索引。如果也没有这样的唯一索引，则 InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引。 

## 六、SQL语句调优

一 连表查询优化 1 如果是表连接查询,使用小表驱动大表。 inner join 会自动选择小表作为驱动表。 left join 将左边的表当作驱动表,所以left join应该将小表放 到左边。 right join将右边的表当作驱动表,所以right join应该将小表 放到右边。 2 连表查询,给连接字段添加索引 二 组合索引的使用规则 1 满足等值匹配原则:where条件里的几个字段都是基于等值来查 询, 几个字段的名称和顺序跟联合索引一模一样 2 最左前缀原则:like语句操作 应该写成 like “值%” 3 最左匹配原则: 根据组合索引的最左侧的部分字段来查 4 范围规则:如果有范围查询,将范围查询的条件放到组合索引的最 后 5 等值匹配+范围匹配:联合索引的最左侧的多个字段进行 等值匹 配+范围搜索 三 MySQL深度分页问题 给查询条件添加索引,使用此索引查询先查出来主键id。此时查询 直接使用的是覆盖索引,不需要回表。然后将查出来的数据作为临 时表然后连接原表就可以了，这样只需要对查询出来结果进行数 据回表。 四 索引的其他使用的规则 1 表中的索引不能太多 一般情况下2-3个组合索引 配合1-2个单字 段索引进行查询 2 主键索引保证是有序的(否则数据库需要页分裂) 3 根据where条件 order by条件 group by条件创建组合索引。组 合索引组好能够覆盖where group by order by 如果覆盖不了,尽 量让where字段使用索引 4 如果字段的取值比较少,可以不用索引 5 不要在索引上进行计算,不要在索引使用函数 6 使用覆盖索引: 查询需要的字段值直接在索引树里就能提取出 来，不需要回表到聚簇索引查询 7 避免使用select * 查询 8 索引不要包含有NULL值 9 force index: MySQL在执行sql语句时有时不按照我们添加的索 引执行,可以使用force index强制其使用索引 五 使用Explain关键字查看SQL语句的执行计划, 是否使用索引, 索 引类型是什么? 我们需要关注的列: id 查询编号 type 本次查询表连接的类型 possible_keys 可能使用的索引 key 实际使用的索引 extra 额外信息 我们要关注下type列的取值, type取值的性能从高到低顺序 system > const > eq_ref > ref > rang > index > all system: 表中只有一条记录 查询条件主键或者唯一索引 const: 查询条件主键或者唯一索引 eq_ref: 通过主键连表查询 ref: 查询条件是非聚簇索引 range: 查询条件是一个范围 index: 查询的所有字段都是非聚簇索引的字段。 all: 全表扫描 常见的extra显示的内容: using filesort: 排序时没有使用索引 using tempoary: 分组时没有使用索引 Using join buffer(Block Nested Loop): 连表查询时没有使用索 引,使用的是块嵌套查询 

## 七、MVCC机制

MVCC 是一种并发控制的方法，实现对数据库的并发访问,以提高 并发性能。MVCC主要用到了Undo Log链和Read View数据结 构。在数据修改之前会把数据拷贝一份到undo log，每条 undo_log数据都有两个隐藏字段,一个是DB_TRX_ID 表示最近一 次更新这条数据的事务ID。一个是DB_ROLL_PTR 指向更新这条 数据之前生成的undo lock数据。 在数据库隔离级别是读已提交,每次执行查询的时候都会创建 ReadeView。隔离级别是可重复读，仅在第一次查询的时候生成 ReadView，后续复用此ReadView。 ReadView 包括四个字段: m_ids 当前活跃的事务编号 min_trx_id:最小活跃事务编号 max_trx_id:预分配事务编号，当前最大事务编号+1 creator_trx_id:ReadeView创建者的事务编号 

## 八、MySQL 连接算法

Simple Nested-Loop Join（简单嵌套循环连接） 驱动表A 中拿取关联条件A1 匹配被驱动表B所有列，得到结果记 录。继续A2,A3…直到驱动表A 中所有关联条件匹配完。然后合并 所有记录，这种算法要对被驱动表B 进行 An 次访问，而且每次访 问被驱动表B 都是全表扫描，性能非常差 Index Nested-Loop Join (索引嵌套循环连接) 从驱动表A中拿取关联条件A1 匹配被驱动表B，被驱动表B 是基于 索引查询非常快(不用全表扫描)，得到结果记录。继续A2,A3… 直 到驱动表A中所有关联条件匹配完。这种算法要对被驱动表B 进行 An 次访问，而被驱动表B 每次基于索引查询是非常快的，性能完 全取决于驱动表A 的关联条件条数。 Block Nested-Loop Join (块嵌套循环连接) 在有索引的情况下，MySQL 会尝试去使用 Index Nested-Loop Join 算法，在有些情况下，可能 Join 的列就是没有索引，那么这 时 MySQL 的选择绝对不会是最先介绍的 Simple Nested-Loop Join 算法，而是会优先使用Block Nested-Loop Join 的算法。 （此句不要背诵自己看看就好） Block Nested-Loop Join 对比 Simple Nested-Loop Join 多了一个中间处理的过程，也就是 join buffer，使用 join buffer 将驱动表的查询 JOIN 相关列都给缓冲到了 JOIN BUFFER 当中， 然后批量与非驱动表进行比较，这也来实现的话，可以将多次比 较合并到一次，降低了非驱动表的访问频率。 

## 九、MyCat中balance属性的取值有哪些

 balance:0 不开启读写分离机制 balnace:1 全部的readHost与stand by writeHost参与select语 句的负载均衡 balance:2 所有readHost与wirteHost都参与select语句的负责均 衡 balance:3 所有readHost参与select语句的负载均衡。 10 MyCat中switchType属性的取值有哪些 switchType:1 表示当writeHost不可使用的时候,可以自动切换到 第二个writeHost中。 switchType:-1 表示当writeHost不可使用的时候,不要自动切换。 如果是一主多从架构,并且使用了MHA等MySQL高可用管理工具 时,需要将此属性改为-1。 

10 MyCat中writeType属性的取值有哪些 writeType:0 表示所有的写操作全部在第一个writeHost中完成,只 有第一个writeHost失败了,才向第二个中写入。 writeType:1 表示写操作随机的分配到writeHost中。 

11 使用MyCat垂直分库以后如何进行跨数据库连表查询 方案1: 如果只需要跨库跨表查询几个字段,我们可以直接在对应的 表中添加冗余字段即可。但是这些字段的值不能经常改变。 方案2: 使用API方式,从对应的数据库中查询数据然后在业务代码 中进行组装。 方案3: 使用全局表的方式。在需要跨库表连接的数据库中都添加 需要被连接的表,在MyCat中使用type="global",将此表配置为全 局表。通过MyCat修改全局表数据时,所有数据库中的此表数据都 会被修改。表连接查询时,会使用自己数据库中此表进行查询。 

12 MySQL数据库主从同步的方式有哪些 异步复制: MySQL默认的复制即是异步的，主库在执行完客户端提交的事务 后会立即将结果返给客户端，并不关心从库是否已经接收并处 理，这样就会有一个问题：主如果挂掉了，此时主上已经提交的 事务可能并没有传到从上，如果此时，强行将从提升为主，可能 导致新主上的数据不完整。 全同步复制: 指当主库执行完一个事务，所有的从库都执行了该事务才返回给 客户端。因为需要等待所有从库执行完该事务才能返回，所以全 同步复制的性能必然会收到严重的影响。 半同步复制: 介于异步复制和全同步复制之间，主库在执行完客户端提交的事 务后不是立刻返回给客户端，而是等待至少一个从库接收到并写 到relay log中才返回给客户端。相对于异步复制，半同步复制提 高了数据的安全性。为了减少半同步方式从数据库数据与主数据 库数据不一致的时间,我们可以在从数据库中配置多个线程进行同 步。 

13 InnoDB 引擎的数据库表,如果没有在表上创建主键,这张表是否存 在主键 如果表中没有定义主键，则InnoDB会选择第一个不包含有NULL 值的唯一索引作为主键索引。如果也没有这样的唯一索引，则 InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引 (ROWID随着行记录的写入而主键递增，这个ROWID不ORACLE 的ROWID那样可引用，是隐含的)。 

14 left join inner join right Join的区别? left join:“左连接”，左表连接右表，以左为主，表示以左表为 主，关联上右表的数据，查出来的结果显示左边的所有数据，然 后右边显示的是和左边有交集部分的数据。 right join：“右连接”，右表连接左表，以右为主，表示以右表 为主，关联查询左表的数据，查出右表所有数据以及左表和右表 有交集的数据。 join（inner join）:“内连接”，表示以两个表的交集为主，查出 来是两个表有交集的部分，其余没有关联就不额外显示出来。 

15 索引是什么? 索引分类? 主键索引和唯一索引的区别? 索引是什么 索引是B+树结构,可以帮助MySQL高效获取数据。 索引分类 聚簇索引: 使用主键字段当做索引 非聚簇索引: 非主键字段当做索引 唯一索引与主键索引的区别 主键一定是唯一性索引， 唯一性索引并不一定就是主键。 一个表中可以有多个唯一性索引，但只能有一个主键。 主键列不允许空值，而唯一性索引列允许空值。 

16 MySQL存储引擎有哪些 MYISAM：拥有较高的执行速度，不支持事务，不支持外键，并 发性能差，占用空间相对较小，对事务完整性没有要求。 InnoDB:   提供了具有提交、回滚和崩溃回复能力的事务安全，支 持自动增长列，支持外键约束，并发能力强。 Memory:存储在内容中，速度快，但会占用和数据量成正比的内 存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索 效率非常高，但不适用于精确查找。

18 order by 与 group by的区别 ORDER BY子句用于按升序或降序排列. GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集 进行分组